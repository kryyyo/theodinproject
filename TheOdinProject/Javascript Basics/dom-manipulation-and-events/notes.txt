DOM
    Document Object Model 
    tree-like representation of the contents of a webpage
    a tree of 'nodes'

'selectors'
    used to target the nodes you want to work with
    
    CSS style selectors and relationship properties to target the nodes you want
        eg.  <div class="display"></div>
                    div.display
                    .display
                    #container > .display
                    div#container > div.display

    relational selectors 
        firstElementChild or lastElementChild etc. 
    
        eg. container.firstElementChild

DOM Methods 
    use to manipulate our webpage with Javascript

    Query Selectors 
        -element.querySelector(selector) returns a reference to the first match of selector

        -element.querySelectorAll(selectors) returns a “nodelist” containing references to all of the matches of the selectors
            -return value of this is NOT AN ARRAY even though it may look like an array
            -return value is a 'nodelist'
            -big difference is array methods are not all available in a nodelist 
                -a solution for this is to convert the nodelist into an array

                    syntax:
                        Array.from()

                -or a spread operator
                        (...arrayName)

    Element Creation
        Syntax:
            document.createElement(tagName, [options])
        
        creates a new element of tag type tagName
        [options] means you can add some optional parameters to the function

        eg. 
            const div = document.createElement('div');

        this does not put your new element into the DOM 
        creates only, store in the memory
        so you can manipulate first the element before placing it on the page
            adding styles,classes, ids, text, etc
        
    Append Elements
       method for placing the element you created and manipulated 

        parentNode.appendChild(childNode)
            appends childNode as the last child of parentNode
        
        parentNode.insertBefore(newNode, referenceNode)
            inserts newNode into parentNode before the referenceNode

    Remove Elements
        parentNode.removeChild(child)
            removes the child from the parentNode on the DOM and returns a reference to child

    Altering Elements
        containing a created element in a variable so we can alter/manipulate it easier
            const div = document.createElement('div')

        Adding inline style
            eg.
                //using JS property
                div.style.color = 'blue'

                //using CSS property
                div.style.cssText = 'color: blue; background: white';

                //using CSS property
                div.setAttribute('style', 'color: blue; background: white');

                //using CSS property
                div.style['background-color']  

        We can remove inline style by setting the value to an empty string
            eg. 
                div.style.color = '';
                div.style.cssText = '';
                div.setAttribute('');   

        Property names here does not contain the usual kebab case in CSS. and because we are in Javascript, we convert the kebab to a camelCase. just remove hyphens and apply camelCase
            in the case that a property name is a Javascript keyword (reserved words), the property name is prefixed with css
                eg. cssText, cssFloat

        Shorthand properties are also available
        
        Do not forget units! 

        Full list of CSS Property to Javascript Property
        http://domenlightenment.com/#6.2


        Other methods for adding and removing

            we can also use .setProperty(property, value) for adding
                where property is in the syntax of CSS (kebab-style)

                eg. divStyle.setProperty('background-color', 'red')

            .getPropertyValue(property) for reading
                getting the current value of the property
                
                eg. divStyle.getPropertyValue('background-color')

            .removeProperty(property) for deleting 

                eg. divStyle.removeProperty('background-color')

            Other methods so we can use css property syntax:
            https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration

    Editing Attributes
        .setAttribute('attribute', 'value')
            if property already exists, it updates its value
            if it still does not exists, it creates the property with the corresponding value 
            value is always a string even if it is a measurement

        .getAttribute('property')
            reads the value of the specified property

        .removeAttribute('property')
            remove the property 
        
        IDL Attribute
            Interface Definition Language Attribute
            Javascript properties
            not always strings 

            eg. input.maxLength = numberValue (expects a number)

            when you put a string eg "200", it will convert it into number (JS conversion)

        Boolean Attribute 
            eg. required, readonly, disabled 
            
            if a boolean attribute is present, its value is true 
            if it is not present, its value is false 

            to be clear, boolean attributes dont need values to be indicated

            eg:
                <input checked></input>             //checked is true
                <input></input>                     //checked is false 
                <input checked="false"></input>     //checked is true since it is indicated! 

Working with classes 
    div.classList.add(className)
        adds class to your div 

    div.classList.remove(className)
        remove the class from div 

    div.classList.toggle(className)
        if your div doesnt have this className specified, it will add it
        if your div has it, it will remove it

    note: it is often the standard (and cleaner) to use toggle because it uses both functions already

Adding text content 
    div.textContent = ''
        create a text node containing the message, and insert it in the div 

Adding HTML content
    div.innerHTML = '<span>Message</span>'
        renders the HTML inside div
        nag aadd sa pinakaHTML! it can modify the main HTML!
        it can inject JS on a page! some scripts can get sensitive information using this innerHTML! 

        just change it .innerText

        if you will use this innerHTML, make sure that no user input can make it through without being sanitized

important note: textContent is preferable because adding HTML content can create security risks if misused.

Keep in mind: JS does not alter your HTML (original file), but the DOM only! 

Where to put the JS External File linking? 
    put it before the closing tag of the body so that all the HTML will load first thus creating the DOM

    if we put it in the head tag, JS is read first, thus no manipulation will be done in the DOM since it is not created/loaded yet 

    there is an easy fix if there is an instance that a js file is in the head tag
        include a defer attribute in the script tag
            <script src='./js-file.js defer></script>

            defer makes the js file load after the HTML is parsed and DOM is created

Events 
    actions that occur on your webpage
    JS can make our webpage listen and react to events


3 ways
    Method 1
        direct attaching of functions to the HTML Elements 

        <button onclick="alert('Hello World')">Click Me</button>

        less ideal because we're cluttering our HTML
        we can only have 1 'onclick' event per element 

    Method 2
        setting on_event_ property on the DOM object in your JavaScript

        <!-- the HTML file -->
        <button id="btn">Click Me</button>

        // the JavaScript file
        const btn = document.querySelector('#btn');
        btn.onclick = () => alert("Hello World");

        problem again, we can only have 1 'onclick' event per element

    Method 3
        <!-- the HTML file -->
        <button id="btn">Click Me Too</button>  

        // the JavaScript file
        const btn = document.querySelector('#btn');
        btn.addEventListener('click', () => {
        alert("Hello World");
        });

        we have separation of html and JS file 
        we also have allowed multiple event listeners

    Note: all three methods can be used with named functions

    <!-- the HTML file -->
    <!-- METHOD 1 -->
    <button onclick="alertFunction()">CLICK ME BABY</button>

    //JS FILE 
    function alertFunction() {
    alert("YAY! YOU DID IT!");
    }

    // METHOD 2
    btn.onclick = alertFunction;

    // METHOD 3
    btn.addEventListener('click', alertFunction);

    RECOMMENDED! using named function can clean up your code
    especially if you are reusing the function

Accessing more information about the event: 
eg. 
    btn.addEventListener('click', function (e) {
    console.log(e);
    });

    parameter e in the function is an object that references to the event itself

    e.target
        provide information for the target DOM node that was clicked(event)

    you can manipulate the DOM of the target (self) using this
        e.target.style.background = "blue"

Attaching listeners to the groups of node
    use querySelectorAll('selector')
    then treat the nodelist as an array 

    const buttons = document.querySelectorAll('button')

    buttons.forEach( (button) => {
        button.addEventListener('click', ()=> alert(button.id))
    }

    HTML DOM Event Object Reference
    https://www.w3schools.com/jsref/dom_obj_event.asp

to make up an attribute name put it here so html will still read it 

    data-madeUpAttribute = ''

Bubbling
    triggering a nested element will trigger all its parent up to the root element 

    because it captures all events from the parent up to the nested child element, then it triggers/bubble up from the child to the parents 

Eloquentjavascript.net

talksAbout function
    talksAbout(target, query)

Finding Elements 

.getElementByTagName('tagname')[index]

.getElementById('id name')
    no index since isa lang ang id name 

.getElementByClassName('class name')[index]


Changing the Document 

document.parentNode.appendChild(childNode)

document.parentNode.insertBefore(newChildNode, siblingNode)
    works best for arrays or nodelists 

document.parentNode.replaceChild(newChildNode, siblingNode)

Creating Nodes 

    Text Nodes
        document.createTextNode

    Array.from(nodelistName) 
        to create a real array and use all methods of an array

Attributes 
    .setAttribute('attribute','value')
    .getAttribute('attribute')

    prefix 'data-' for all made up attributes so that it will not conflict with predefined attributes 

Layout
    offsetWidth and offsetHeight
        gives you the space the element takes up in pixels
    
    clientWidth and clientHeight
        gives you the size of the space inside the element ignoring the border width 

    getBoundingClientRect
        returns an object with top, bottom, left, and right properties
        pixel positions of the sides of the element relative to the top left of the screen 

        for relative to the whole document, you must add the current scroll position 
            pageXOffset and pageYOffset

Positioning and Animating 
    Positions
        static
            -sits in a normal place
        relative
            -top and left style properties can be used to move it relative to that normal place
        absolute
            -element is removed from the normal flow
            -does not take up space and may overlap with other elements 
            -top and left properties can be used to absolutely position it relative to the top-keft corner of the nearest enclosing element whose position property isnt static

    requestAnimationFrame
        schedule the animate function to run whenever the browser is ready to repaint the screen
        
        lets browsers know that we are done for now and it can go ahead and do the things that browsers fo

    note: using numbers without units will result in the style being ignored. (except if your number is 0)


EVENT HANDLERS
    .addEventListener('event', functionToBeDoneAfterEvent)

EVENTS AND DOM NODES
    .removeEventListener('event', functionOfAddEventListener)

    parameters of add event and remove event should be the same! 

    so it is best to have a named function for the second parameter of .addEventListener so that we can easily remove the event lister of an object

EVENT OBJECT
    this is like the keydown property (where we have many unicode numbers associated per key) 

    eg.
    <button>Click me any way you want</button>
    <script>
    let button = document.querySelector("button");
    button.addEventListener("mousedown", event => {
        if (event.button == 0) {
        console.log("Left button");
        } else if (event.button == 1) {
        console.log("Middle button");
        } else if (event.button == 2) {
        console.log("Right button");
        }
    });
    </script>

PROPAGATION
    (this is like bubbling)
    from the node where it happened to that node’s parent node and on to the root of the document

    .stopPropagation() method
        this is to prevent propagating up/bubbling up

    using target property
        use target property if there are instances where there are many similar elements that needs a stopPropagation. listen from the parentNode then target the childNodes of the same element

        eg. 

            <button>A</button>
            <button>B</button>
            <button>C</button>
            <script>
            document.body.addEventListener("click", event => {
                if (event.target.nodeName == "BUTTON") {
                console.log("Clicked", event.target.textContent);
                }
            });
            </script>

DEFAULT ACTIONS
    eg: pressing down arrow will scroll page, right-clicking can get context menu, clicking a link will redirect you


    .preventDefault() method

        if the handler doesn't want to call before the default behavior takes place, use this

        to implement own keyboard shortcutes, context menus...

        to interfere with the behavior that users expect 

    eg. Preventing redirection of a link

        <a href="https://developer.mozilla.org/">MDN</a>
        <script>
        let link = document.querySelector("a");
        link.addEventListener("click", event => {
            console.log("Nope.");
            event.preventDefault();
        });
        </script>

    Depending on the browser, some default actions cannot be prevented like ctrl+w for chrome

KEY EVENTS
    'keydown' event - pressed
    'keyup' event - released 

    take note of this: for key holding, it is keydown event that is repeating! 

    for combination of keys: 
        .shiftKey
        .ctrlKey
        .altKey
        .metaKey (for mac) 

        && event.shiftKey 

    tabindex property   
        for focusing of DOM nodes
        just like in visual basic 

POINTER EVENTS 
    2 ways to point at things in the screen
        1. mice (mouse, touchpads and trackballs)
        2. touchscreens 

    MOUSE CLICK 
        'mousedown', 'mouseup' same as keydown and keyup
        DOM nodes that are immediately below the mouse pointer when the event occurs 

        after mouseup event, a click event happens:
            get most speciic node that contained both the press and the release of mouse
            
            eg. mouse down on one paragraph, mouse up on another paragraph, both paragraph will trigger click event
    
        'dblclick' - double click event 
            two clicks happen close together 

        clientX and clientY
            to locate where the mouse event happened 
            in pixels
            origin: top left corner of screen 

        pageX and pageY
            origin: top left corner of the WHOLE document
        
        eg. (parang etch-a-sketch to)

        <style>
        body {
            height: 200px;
            background: beige;
        }
        .dot {
            height: 8px; width: 8px;
            border-radius: 4px; /* rounds corners */
            background: blue;
            position: absolute;
        }
        </style>
        <script>
        window.addEventListener("click", event => {
            let dot = document.createElement("div");
            dot.className = "dot";
            dot.style.left = (event.pageX - 4) + "px";
            dot.style.top = (event.pageY - 4) + "px";
            document.body.appendChild(dot);
        });
        </script>

MOUSE MOTION 
    'mousemove' - everytime mouse pointer moves 

    used to track position of mouse
    useful for mouse dragging functionality 

    .buttons property
        tells us if buttons are currently held down
            0 - not held down
            1 - left button held down 
            2 - right button held down 
            3 - both left and right held down 
            4 - middle held 

    .button property
        tells us the button doing the event
            0 - left button
            1 - middle button 
            2 - right button 

TOUCH EVENTS 
    'touchstart' event 
        finger touch screen 

    'touchmove'
        move while touching (hold)

    'touchend' 
        stops touching the screen

    touches Property    
        array-like object of points since event objects doesnt have a single set of coordinates with them (multiple fingers touching whereas there is only one mouse pointer)

        each array-like object has clientX, clientY, pageX, and pageY properties

        we can loop through each event.touches so we can simulate every touching finger

        note: preventDefault override the browser's default behavior like:
            scrolling the page on swiping
            prevent mouse events from bei
            
SCROLL EVENTS 
    'scroll' event
        uses:
            where the user is currently looking at

            showing indications of progress

    event handler is only called after the scrolling takes place that's why preventDefault does not prevent the scrolling from happening

FOCUS EVENTS 
    'focus' event  
        gains focus 

    'blur'
        loose focus

    these two events do not propagate! 

LOAD EVENT 
    'load' event
        when a page finishes from loading
        actions that require the whole document to be built 
        when the references/external files were loaded 

    loading events do not propagate! 

    'beforeunload' event 
        page is closed or navigated away from 
        main use is to prevent the user from accidentally losing work by closing a document 

        preventDefault and returnValue set to string
            this will show a user dialog like this: 

            eg. "are you sure you want to follow this link?" 

EVENTS AND THE EVENT LOOP 
    web workers 
        JS process that runs alongside the main script on its own timeline 
        does not hinder the page loading process 

        do not share their global scope with the main script

        eg 
            let squareWorker = new Worker("code/squareworker.js");
            squareWorker.addEventListener("message", event => {
            console.log("The worker responded:", event.data);
            });
            squareWorker.postMessage(10);
            squareWorker.postMessage(24);

        only values that can be represented as JSON can be sent as message (so parang strings)
        
        copy lang marereceive nung other side, not the real value

TIMERS 
    'setTimeout' function
        schedules another function to be called later after given a number of milliseconds 

    canceling a function you have scheduled:

        storing the value returned by setTimeout
        calling clearTimeout on it 

        eg. 
            let bombTimer = setTimeout(() => {
            console.log("BOOM!");
            }, 500);

            if (Math.random() < 0.5) { // 50% chance
            console.log("Defused.");
            clearTimeout(bombTimer);
            }


    'cancelAnimationFrame' works the same as clearTimeout 
        you need to store first the value returned by requestAnimationFrame, then call cancelAnimationFrame

    'setInterval' and 'clearInterval' 
        works the same too 

DEBOUNCING
    this is like setting a timeout for the firing the event 

    eg. someone is typing too fast, you do not want to record every keypress of it, because it will fire too many events. instead, you fire a keypress event after sometime the user has paused typing 

    eg. 

        <textarea>Type something here...</textarea>
        <script>
        let textarea = document.querySelector("textarea");
        let timeout;
        textarea.addEventListener("input", () => {
            clearTimeout(timeout);
            timeout = setTimeout(() => console.log("Typed!"), 500);
        });
        </script>

DOM Enlightenment

CHAPTER 1 Node Overview 
    1.1 
        DOM
            hierarchy/tree of Javascript node objects 
        
        scripting 
            removing, adding, replacing, eventing, modifying

        Note:
            DOM was originially an api for XML documents that has been extended for use in HTML documents
    
    1.2
        Node Object Types
            MOST COMMON TYPES OF NODES
                -DOCUMENT_NODE (eg. window.document)

                -ELEMENT_NODE (eg. <body>, <a> ...)

                -ATTRIBUTE_NODE (eg. class="funEdges")

                -TEXT_NODE (eg. text characters in an html 
                including carriage returns and whitespace)

                -DOCUMENT_FRAGMENT_NODE (eg. document.createDocumentFragment())

                -DOCUMENT_TYPE_NODE (eg. <!DOCTYPE html>)

            These are the properties for the Node object! 
            Node.DOCUMENT_NODE .... 

            The node properties are constant values that are used to store numeric code values for each type of node object 

            Extensive list:
                ELEMENT_NODE  = 1
                ATTRIBUTE_NODE  = 2
                TEXT_NODE  = 3
                CDATA_SECTION_NODE  = 4
                ENTITY_REFERENCE_NODE  = 5
                ENTITY_NODE  = 6
                PROCESSING_INSTRUCTION_NODE  = 7
                COMMENT_NODE  = 8
                DOCUMENT_NODE  = 9
                DOCUMENT_TYPE_NODE  = 10
                DOCUMENT_FRAGMENT_NODE  = 11
                NOTATION_NODE  = 12
                DOCUMENT_POSITION_DISCONNECTED  = 1
                DOCUMENT_POSITION_PRECEDING  = 2
                DOCUMENT_POSITION_FOLLOWING  = 4
                DOCUMENT_POSITION_CONTAINS  = 8
                DOCUMENT_POSITION_CONTAINED_BY  = 16
                DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC  = 32
            
            Most Common when scripting: 
                HTML*Element (eg. HTMLBodyElement)
                    -1 ELEMENT_NODE
                Text 
                    -3 TEXT_NODE
                Attr
                    -2 ATTRIBUTE_NODE 
                HTMLDocument 
                    -9 DOCUMENT_NODE
                DocumentFragment
                    -11 DOCUMENT_FRAGMENT_NODE
                DocumentType
                    -10 DOCUMENT_TYPE_NODE

        NOTES: 
            ATTRIBUTE_NODE 
                not necessarily part of the tree but listed for historical reasons 

                these are like subnodes for element nodes 
            
            COMMENT_NODE
                are TEXT_NODE 
            
    1.3 Sub-node objects inherit from the NODE object
        all node types inherit from NODE


        Inheritance model: 
            Object < Node < Element < HTMLElement < HTML*Element

            Object < Node < Attr (deprecated in DOM 4)

            Object < Node < CharacterData < Text

            Object < Node < Document < HTMLDocument 

            Object < Node < DocumentFragment

    1.4 Properties and methods for working nodes 

        Node Properties
            -childNodes
            -firstChild
            -lastChild
            -nextSibling
            -nodeName
            -nodeType
            -nodeValue 
            -parentNode
            -previousSibling 

        Node Methods
            -appendChild()
            -cloneNode()
            -compareDocumentPosition()
            -contains()
            -hasChildNodes()
            -insertBefore()
            -isEqualNode()
            -removeChild()
            -replaceChild()
        
        Document Methods
            -document.createElement()
            -document.createTextNode()

        HTML*Element Properties 
            -innerHTML 
            -outerHTML
            -textContent
            -innerText
            -outerText
            -firstElementChild
            -lastElementChild
            -nextElementChild 
            -previousElementChild
            -children 

        HTML element Methods 
            -insertAdjacentHTML()

    1.5 Identifying the type and name of a node 

        every node has a nodeType and nodeName property that is inherited from Node

        Eg. 
            Text nodes
                nodeType code = 3
                nodeName = '#text'


        .nodeType and .nodeName property

            eg:
                document.doctype.nodeName //html 
                document.doctype.nodeType //10

                document.nodeName // '#document'
                document.nodeType // 9

                document.createDocumentFragment().nodeName, //'#document-fragment'
	            document.createDocumentFragment().nodeType // 11

                document.querySelector('a').nodeName, //'A'
	            document.querySelector('a').nodeType //1

                document.querySelector('a').firstChild.nodeName, //'#text'
	            document.querySelector('a').firstChild.nodeType //3

        It is importatnt to determine the type of node that you might be scripting so you can see the properties and methods that are available to script the node 

    1.6 Getting a nodes value

        .nodeValue Property
            returns null for most of node types except Text and Comment Nodes 

            use for extracting text and comment nodes 

        eg. 

        //logs null for DOCUMENT_TYPE_NODE, DOCUMENT_NODE, DOCUMENT_FRAGMENT_NODE, ELEMENT_NODE below
        console.log(document.doctype.nodeValue);
        console.log(document.nodeValue);
        console.log(document.createDocumentFragment().nodeValue);
        console.log(document.querySelector('a').nodeVale);

        //logs string of text
        console.log(document.querySelector('a').firstChild.nodeValue); //logs 'Hi'

        text or comment node values is overwritten (not added) if you place a new value for it

        eg. 

        document.body.firstElementChild.nodeValue = 'hello'



    1.7 Creating element and text nodes using Javascript methods 

        2 Methods :

            1. .createElement()
                    1 parameter = string of what you will create as an <element>

            2. .createTextNode()

        Other methods but not used: 
            1. .createAttribute()
                    depricated and should not be used 

            2. .createComment()

    1.8 Creating and adding element and text nodes to the DOM using JavaScript strings 

        .innerHTML, .outerHTML, .textContent and insertAdjacentHTML() 
        
        .innerHTML
            -put literally inside the target HTML <element>
            -actual DOM nodes 

            eg. 

            <div id="A"></div>
            
            document.getElementById('A').innerHTML = '<strong>Hi</strong>';

            // <div id="A"><strong>Hi</strong></div>

        .outerHTML
            -put literally @ the target HTML <element> and replace
            -if there are no target HTML <element>, add 

            <span id="B"></span>

            document.getElementById('B').outerHTML = '<div id="B" class="new">Whats Shaking</div>'

            //<div id="B" class="new">Whats Shaking</div>

        .textContent
            -create text node and update the text node of the target HTML <element> (replace the text node value)
            -text nodes only (even if you pass an element like string)


            <div id="C"></div>

            document.getElementById('C').textContent = 'dude';

            //<span id="C">dude</span>


        (NON STANDARD EXTENSIONS)
        .innerText
            -create text node and update text node (parang textContent)

            <div id="D"></div>

            document.getElementById('D').innerText = 'Keep it';

            //<div id="D">Keep it</div>

        .outerText 
            -create text node and replace target element/text 

            <div id="E"></div>

            document.getElementById('E').outerText = 'real!';

            //real!

        Note! basta pag mga outer, nagrereplace/remove siya! 

        target.insertAdjacentHTML('position', 'inserted')
            only works for element nodes and is a good deal and more precise way!

            literally ilalagay mo sa katabi nya
            (not replacing/removing anything)

            2 parameters 
                position: 
                    'beforebegin' - before opening tag of target
                    'afterbegin' - after opening tag of target
                    'beforeend' - before closing tag of target
                    'afterend' - after closing tag of target

                inserted:
                    enclose in a string what you want to insert


        Notes: 

        document.write() can also be used to create and add nodes but not typically used anymore unless required by 3rd party scripting tasks
            basically:
                write() 
                    will stall/block the parsing of the html document being loaded 

        'beforebegin' and 'afterend'
            will only work if the target node has a parent node and is in the DOM tree (not a text node)

        outerHTML
            not available in firefox natively until version 11
            polyfill is available 

        textContent vs innerText 
            textContent gets the content of all elements including <script> and <style> 

            innerText does not 

            innerText is aware of the style and will not return the text of hidden elements, whereas textContent will

            parang yung textContent ay kung ano talaga yung nasa html file, while yung innerText ay kung ano yung pinarse na sa DOM (just my own analogy)

        @ Firefox: 
            insertAdjacentElement()
            insertAdjacentText()

    1.9 Extracting parts of the DOM tree as JavaScript strings 

        same properties that we use to create and add nodes are for extracting as a JavaScript String 

        eg. 

        <div id="A"><i>Hi</i></div>
        <div id="B">Dude<strong> !</strong></div>

        <script>

        console.log(document.getElementById('A').innerHTML); //logs '<i>Hi</i>'

        console.log(document.getElementById('A').outerHTML); //logs <div id="A">Hi</div>

        //notice that all text is returned even if its in child element nodes (i.e. <strong> !</strong>) 
        console.log(document.getElementById('B').textContent); //logs 'Dude !'

        //NON standard extensions below i.e. innerText & outerText

        console.log(document.getElementById('B').innerText); //logs 'Dude !'

        console.log(document.getElementById('B').outerText); //logs 'Dude !'​​

        Notes: 
            textContent, innerText, outerText 
                return all of the children text nodes! 

    1.10 Adding node objects to the DOM using appendChild() & insertBefore() 

        appendChild()
            append a node to the END of the child node(s) of the node the method is called on 

        insertBefore(nodeToBeInserted, referenceNode)
            inserting a node before the selected referenceNode 

            if referenceNode === null 
                it functions as appendChild()

    1.11 Removing and replacing nodes using removeChild() and replaceChild()

        .removeChild(childNode)
            1. select node you want to remove 
            2. access its parentNode
            3. then .removeChild

        //remove element node
        var divA = document.getElementById('A');
        divA.parentNode.removeChild(divA);

        //remove text node
        var divB = document.getElementById('B').firstChild;
        divB.parentNode.removeChild(divB);

        //log the new DOM updates, which should only show the remaining empty div#B
        console.log(document.body.innerHTML);

        .replaceChild(newNode, referenceNode) 
            1. select node you want to remove 
            2. access its parentNode 
            3. .replaceChild(newChild, oldChild)

        Notes:
            innerHTML, outerHTML, and textContent with an empty string is easier and faster than these methods (but prone to memory leaks)

            both replaceChild() and removeChild() return the replaced or removed node
                basically it's not gone, you still have a reference to it in memory 

    1.12 Cloning nodes using cloneNode()
        duplicate a single node or a node and all its children node 

        single node only: .cloneNode()

            <ul>
            <li>Hi</li>
            <li>there</li>
            </ul>

            <script>

            var cloneUL = document.querySelector('ul').cloneNode();

            console.log(cloneUL.constructor); //logs HTMLUListElement()
            console.log(cloneUL.innerHTML); //logs (an empty string) as only the ul was cloned

            </script>

        node and its children: .cloneNode(true)

            <ul>
            <li>Hi</li>
            <li>there</li>
            </ul>

            <script>

            var cloneUL = document.querySelector('ul').cloneNode(true);

            console.log(cloneUL.constructor); //logs HTMLUListElement()
            console.log(cloneUL.innerHTML); //logs <li>Hi</li><li>there</li>

            </script>

        note:
            all attributes and values are also cloned
            only attributes are copied! 
            everything else like event handlers is lost when cloning 

            cloneNode(true) does not return a NodeList

            cloneNode() may lead to duplicate element IDs (it does not query if there is an existing id already)
                copy lang ng copy 

    1.13 Grokking node collection

        ie. NodeList
            (document.querySelectorAll(*))

            HTMLCollection
            (document.scripts)

        Array-like objects 

        Characteristics:
            -collection can either be live or static 
                -nodes in a collection are either literally part of the live document or a snapshot of the live document 

            -nodes are sorted inside of the collection by tree order 

            -collections have a length properrty that reflects the number of elements in the list (elementNodes not textNodes)

    1.14 Getting a list/collection of all immediate child nodes 
        .childNodes Property
            produces an array like list of the IMMEDIATE child nodes 
        
        note: 
            childnodes contain also immediate text and comment nodes 

            [].forEach pwede na gamitin 

    1.15 Convert a NodeList or HTMLCollection to JavaScript Array 
        confirming if it is an array:
            use Array.isArray(nodelist/htmlcollection)
                -will return false 

        Advantages of converting a nodelist/collection into an array:
            1. create a snapshot of the list that is not tied to the live DOM (nodelist and htmlcollection are live lists) 
            2. gives access to methods of an Array object 

        .call(nodelist/collection) or apply(nodelist/collection)

            eg.
                console.log(Array.isArray(Array.prototype.slice.call(document.links))); //returns true

                console.log(Array.isArray(Array.prototype.slice.call(document.querySelectorAll('a')))); //returns true
        
        note: ES6 we already have an Array.from() for converting into array

    1.16 Traversing nodes in the DOM 
        from a node reference, traverse through the DOM by these properties: 

            -parentNode
            -firstChild
            -lastChild
            -nextSibling
            -previousSibling

        eg.
            <!DOCTYPE html>
            <html lang="en">
            <body><ul><!-- comment -->
            <li id="A"></li>
            <li id="B"></li>
            <!-- comment -->
            </ul>

            <script>

            //cache selection of the ul
            var ul = document.querySelector('ul');

            //What is the parentNode of the ul?
            console.log(ul.parentNode.nodeName); //logs body

            //What is the first child of the ul?
            console.log(ul.firstChild.nodeName); //logs comment

            //What is the last child of the ul?
            console.log(ul.lastChild.nodeName); //logs text not comment, because there is a line break

            //What is the nextSibling of the first li?
            console.log(ul.querySelector('#A').nextSibling.nodeName); //logs text

            //What is the previousSibling of the last li?
            console.log(ul.querySelector('#B').previousSibling.nodeName); //logs text

            </script>
            </body>
            </html>

        from a node reference, traverse through the DOM ignoring TEXT and COMMENT nodes (element traversing methods)
            -firstElementChild
            -lastElementChild
            -nextElementChild
            -previousElementChild
            -children - //HTMLcollection, all child nodes including text nodes

        note: 
            childElementCount 
                calculating number of child elements a node contains 

    1.17 Verify a node position in the DOM tree with contains() & compareDocumentPosition()
    
        .contains()
            elementNode.contains(containedNode)

            <script>

            // is <body> inside <html lang="en"> ?
            var inside = document.querySelector('html').contains(document.querySelector('body'));

            console.log(inside); //logs true

            </script>

        .compareDocumentPosition()
            same parameters 

            returns: 
                0 - elements are identical

                1 - DOCUMENT_POSITION_DISCONNECTED
                    selected and passed in node are not in the same document 

                2 - DOCUMENT_POSITION_PRECEDING
                    passed in node is preceding selected node

                3 - DOCUMENT_POSITION_FOLLOWING
                    passed in node is following selected node

                8 - DOCUMENT_POSITION_CONTAINS
                    passed in node is an ancestor of selected node

                16, 10 - DOCUMENT_POSITION_CONTAINED_BY (16, 10 in hexadecimal)
                    passed in node is a descendant of selected node 
                
        notes: 
            contains() will return true if identital 

            compareDocumentPosition() can rather be confusing because it is possible for a node to have more than one type of relationship with another node. additive yung nagiging sagot/return value kapag dalawang position

                eg. preceding and contains 
                    return value: 10 
    
    1.18 How to determine if two nodes are identical
        if and only if:
            1. two nodes are of the same type 
            2. following string attributes are equal:
                    -nodeName 
                    -localName
                    -namespaceURI 
                    -prefix
                    -nodeValue

                that is: they are both null, have the same length, and are character for character identical 

            3. attributes NamedNodeMaps are equal
                - both null 
                - have the same length 
                - for each node that exists in one map there is a node that exists in the other map and is equal even not the same index 

            4. childNodes NodeLists are equal 
                -both null
                -have the same length 
                -contain equal nodes at the same index 
                -nodes should be normalized before being compared 

        selectedNode.isEqualNode(comparedNode)

            eg.

                <input type="text">
                <input type="text">

                <textarea>foo</textarea>
                <textarea>bar</textarea>

                <script>

                //logs true, because they are exactly idential
                var input = document.querySelectorAll('input');
                console.log(input[0].isEqualNode(input[1]));

                //logs false, because the child text node is not the same
                var textarea = document.querySelectorAll('textarea');
                console.log(textarea[0].isEqualNode(textarea[1]));

                </script>

        note: you can use === operator for identical but not exactly equal 

CHAPTER 2 - DOCUMENT NODES 

    2.1 document node overview 
            DOCUMENT_NODE (i.e. window.document)

        notes: 
            document.implementation.createHTMLDocument() 
                possible to create your own HTML Document outside of the one currently loaded into the browser 

            .createDocument()
                create a document object
    
    2.2 HTMLDocument properties and methods (including inherited) 
        noteworthy properties and methods 
            doctype
            documentElement
            implementation.*
            activeElement
            body
            head
            title
            lastModified
            referrer
            URL
            defaultview
            compatMode
            ownerDocument
            hasFocus()
    
    2.3 Getting general HTML document information (title, url, referrer, lastModified, compatMode)
        document.title
        document.url
        document.referrer
        document.lastModified
        document.compatMode (compatibility) 
            BackCompat (Quirks Mode) 
            CSS1Compat (Strict Mode)

    2.4 document child Nodes
            one DocumentType node, one Element node 

            <!DOCTYPE html>
            <html lang = "en">

            sila lang dalawa!

        note: this is not the window.document object! 
            window.document is the starting point for the DOM Interface

        if a comment node is outside <html lang = "en">, it will be a child node of window.document not document

        however, comment nodes outside of the html tag can cause some buggy results and a violation of the DOM specification 

    2.5 document provides shortcuts to <!DOCTYPE>, <html lang="en">,<head>, and <body> 

            properties for shortcut references: 

                -document.doctype (<!DOCTYPE>)
                -document.documentElement (<html lang="en">)
                -document.head (<head>)
                -document.body (<body>)

        in Safari, Chrome, and Opera, .doctype is not in childnodes list! only .documentElement
 
    2.6 Detecting DOM specifications/feautures using
    
        document.implementation.hasFeature()

            what feature and level the browser has implemented/supports 

            eg. 
                console.log(document.implementation.hasFeature('Core','2.0'));
                console.log(document.implementation.hasFeature('Core','3.0')); 

        other parameters: (feature, version)
        Core	1.0, 2.0, 3.0
        XML	1.0, 2.0, 3.0
        HTML	1.0, 2.0
        Views	2.0
        StyleSheets	2.0
        CSS	2.0
        CSS2	2.0
        Events	2.0, 3.0
        UIEvents	2.0, 3.0
        MouseEvents	2.0, 3.0
        MutationEvents	2.0, 3.0
        HTMLEvents	2.0
        Range	2.0
        Traversal	2.0
        LS (Loading and saving between files and DOM trees synchronously)	3.0
        LS-Asnc (Loading and saving between files and DOM trees asynchronously)	3.0
        Validation	3.0

        notes:
            use also capability detection in addition to hasFeature() 

            isSupported() is for a specific/selected node only 
                eg. element.isSupported(feature, version)

    2.7 Get a reference to the focus/active node in the document 

        document.activeElement
        
        eg. 

            <textarea></textarea>

            <script>

            //set focus to <textarea>
            document.querySelector('textarea').focus();

            ​//get reference to element that is focused/active in the document
            console.log(document.activeElement); //logs <textarea>

            </script>

    2.8 Determining if the document or any node inside of the document has focus 

        document.hasFocus()

            eg. 
                <script>

                //If you keep focus on the window/tab that has the document loaded its true. If not it's false.
                setTimeout(function(){console.log(document.hasFocus())},5000);

                </script>
    
    2.9 document.defaultview is a shortcut to the head/global object 
            console.log(document.defaultView) //reference, head JS object. Would be window object in a browser.

            if you are dealing with a DOM that is headless or a JS environment that is not running in a web browser (node.js) this property can get you access to the head object scope

    2.10 Getting a reference to the Document from an element using ownerDocument

            .ownerDocument
                returns a reference to the Document the node is contained within
                
            if ownerDocument is called on the Document node, the value is null

CHAPTER 3 - Element nodes
    3.1 HTML*Element object overview 
        
        // grab <a> element node from DOM and ask for the name of the constructor that constructed it
        console.log(document.querySelector('a').constructor);
        //logs function HTMLAnchorElement() { [native code] }

        list of interfaces/constructors used to create HTML elements:
            HTMLHtmlElement
            HTMLHeadElement
            HTMLLinkElement
            HTMLTitleElement
            HTMLMetaElement
            HTMLBaseElement
            HTMLIsIndexElement
            HTMLStyleElement
            HTMLBodyElement
            HTMLFormElement
            HTMLSelectElement
            HTMLOptGroupElement
            HTMLOptionElement
            HTMLInputElement
            HTMLTextAreaElement
            HTMLButtonElement
            HTMLLabelElement
            HTMLFieldSetElement
            HTMLLegendElement
            HTMLUListElement
            HTMLOListElement
            HTMLDListElement
            HTMLDirectoryElement
            HTMLMenuElement
            HTMLLIElement
            HTMLDivElement
            HTMLParagraphElement
            HTMLHeadingElement
            HTMLQuoteElement
            HTMLPreElement
            HTMLBRElement
            HTMLBaseFontElement
            HTMLFontElement
            HTMLHRElement
            HTMLModElement
            HTMLAnchorElement
            HTMLImageElement
            HTMLObjectElement
            HTMLParamElement
            HTMLAppletElement
            HTMLMapElement
            HTMLAreaElement
            HTMLScriptElement
            HTMLTableElement
            HTMLTableCaptionElement
            HTMLTableColElement
            HTMLTableSectionElement
            HTMLTableRowElement
            HTMLTableCellElement
            HTMLFrameSetElement
            HTMLFrameElement
            HTMLIFrameElement

        each of this HTML*Element inherits property from HTMLElement, Element, Node, Object
    
    3.2 HTML*Element object properties and methods (including inherited)

        noteworthy:
            createElement()
            tagName
            children
            getAttribute()
            setAttribute()
            hasAttribute()
            removeAttribute()
            classList()
            dataset
            attributes

    3.3 Creating Elements 

            document.createElement('tagName')

            note: value passed to createElement is changed to a lower-case string before the element is created 

    3.4 Get the tag name of an element 

            .tagName Property
                returns the same value as .nodeName 

            eg. 
                <a href="#">Hi</a>

                <script>

                console.log(document.querySelector('a').tagName); //logs A

                //the nodeName property returns the same value
                console.log(document.querySelector('a').nodeName); //logs A

                </script>

    3.5 Getting a list/collection of element attributes and values 

            .attributes 
                collection of attr nodes 
                returns a list called NameNodeMap

            note: 
                array returned is considered live (can be changed anytime)

                array inherits from NameNodeMap which can use the ff methods:
                    -getNamedItem()
                    -setNamedItem()
                    -removeNamedItem()

                    secondary to using: 
                        -getAttribute()
                        -setAttribute()
                        -hasAttribute()
                        -removeAttribute()

                attributes property is an array-like collection, and has a readonly length property

                Boolean attributes show up in attributes list but no value unless you provide one 

    3.6 Getting, Setting, & Removing an element's attribute value 
            .getAttribute('attribName')
            .setAttribute('attribName', 'value')
            .removeAttribute('attribName')

        note:
            use .removeAttribute instead of setting the value parameter of .setAttribute to null 

            some attributes can be accesed as object properties. please avoid these and use the methods above 


    3.7 Verifying an element has a specific attribute 

        .hasAttribute('specificAttribute')

            return value:
                true - if the attribute is present even with the value of false or null 
                false - not present

    3.8 Getting a list of class attribute values 

            .classList
                return value: 
                    all of the classes with their index

                eg. 
                    console.log(elm.classList); //big brown bear {0="big", 1="brown", 2="bear", length=3, ...}

            .className (not recommended)
                return value:
                    exactly the value including spaces 

                eg. 
                    console.log(elm.className); //logs 'big brown bear'

                not recommended because sometimes we want to target big only, or brown only....

            note: 
                classList - array-like, read-only length property 

                classList - can be modified using the ff:
                    .add()
                    .remove()
                    .contains()
                    .toggle()

                IE9 does not support classlist 
                
    3.9 Adding and Removing sub-values to a class attribute 

        classList.add('className')
        classList.remove('className')
    
    3.10 Togging a class attribute value 

        classList.toggle('className')
            add a class if there is none, remove a class if there is already

    3.11 Determining if a class attribute value contains a specific value 

        classList.contains('value')

    3.12 Getting and Setting data-* attributes 

        dataset Property
            provides an object containing all the attributes of an element starting with data-*

        eg. 

            <div data-foo-foo="foo" data-bar-bar="bar"></div>​

            <script>

            var elm = document.querySelector('div');

            //get
            console.log(elm.dataset.fooFoo); //logs 'foo'
            console.log(elm.dataset.barBar); //logs 'bar'

            //set
            elm.dataset.gooGoo = 'goo';
            console.log(elm.dataset); //logs DOMStringMap {fooFoo="foo", barBar="bar", gooGoo="goo"}

            //what the element looks like in the DOM 
            console.log(elm); //logs <div data-foo-foo="foo" data-bar-bar="bar" data-goo-goo="goo">

            </script>
        
        notes:
            dataset (JS) contains camelCase. JS to HTML will convert the camelCase to kebab case

            removing a dataset:
                delete dataset.*        (js so camelCase)

            not supported in IE9 
                you can always use get/set/remove/hasAttribute('data-*') this is more recommended 

CHAPTER 4 - Element Node Selecting 
    4.1 Selecting a specific element node 

            most common: 
                .querySelector('selector')
                .getElementById('idname')

            where selector can be a CSS Selector syntax 
            idname is as is. no #

            notes: 
                querySelector() will return the first node element found

    4.2 Selecting/creating a list (aka Nodelist) of element nodes 

            most common:

                .querySelectorAll('selector')
                .getElementByTagName('tagName')
                .getElementsByClassName('className')

            notes: 
                NodeLists from getElementsByTagName() and getElementsByClassName() are live and will always reflect the state of the document even if the document is updated 

                querySelectorAll() static, not live

                querySelectorAll(), getElementsByTagName(), and getElementsByClassName are also defined on element nodes. This allows for the method to limit its results to specific vein(s) of the DOM tree (e.g. document.getElementById('header').getElementsByClassName('a'))

                getElementsByName() method is not recommended because many elements can have the same name attribute value (groupings) eg. form, img, frame, radio 

                if the parameter for querySelectorAll() and getElementByTagName() is *, it will return ALL elements of the DOCUMENT 

    4.3 Selecting all immediate child element nodes 

                .children Property
                    immediate only

                eg. 

                    <ul>
                    <li><strong>Hi</strong></li>
                    <li>there</li>
                    </ul>

                    <script>

                    var ulElement = document.querySelector('ul').children;

                    //logs a list/array of all immediate child element nodes
                    console.log(ulElement); //logs [<li>, <li>]

                    </script>
            
            notes: 
                HTMLCollection contains elements in document order, and placed in an array (which means you can access the indexes of each)

                HTMLCollection are live 

    4.4 Contextual element selecting
            you can use querySelector(), querySelectorAll(), getElementsByTagName(), and getElementsByClassName() also on element nodes 

            eg. 
                var div = document.querySelector('div');

                console.log(div.querySelector('ul'));
                console.log(div.querySelectorAll('li'));
                console.log(div.getElementsByTagName('li'));
                console.log(div.getElementsByClassName('liClass'));

            works only for their children 

            also works for programatic DOM structures

    4.5 Pre-configured selections/lists of element nodes 

            legacy, preconfigured arrays-like-list other than the above mentioned earlier 

                noteworthy:

                    document.all - all elements in HTML document
                    document.forms - all <form> elements in HTML document
                    document.images - all <img> elements in HTML document
                    document.links - all <a> elements in HTML document
                    document.scripts - all <script> elements in HTML document
                    document.styleSheets - all <link> or <style> objects in HTML document


            notes:
                document.styleSheets uses StyleSheetList not HTML Collection 

                document.all is constructed from an HTMLAllCollection. not supported in Firefox 

    4.6 Verify an element will be selected using matchesSelector() 

            .matchesSelector('selector') 
                determine if an element will match a selector string

                do not forget the prefixes so it will not return false
                    moz - Firefox 
                    o - Opera
                    ms - Internet Explorer
                    webkit - Chrome, Safari

            note: 
                not recommended because its usage depends on browser 

                it will be renamed as .matches() in the future

CHAPTER 5 - Element Node Geometry & Scrolling Geometry 
    5.1 Element node size, offsets, and scrolling overview 
            most of the properties (excluding scrollLeft and scrollTop) are read only and calculated each time they are accessed 
            values are live 

    5.2 Getting an elements offsetTop and offsetLeft values relative to the offsetParent
            .offsetLeft - returns pixel value 
            .offsetTop - returns pixel value 

            .offsetParent - this is the reference node

            in other words:
                gives us the distance in pixels from an elements outside top and left border to the inside top and left border of the offsetParent

            value of offsetParent is determined by searching the nearest ancestor elements for an element that has a CSS position value not equal to static. 

            if none are found, <body> or document is returned as offsetParent value 


        notes:
            many browsers break the outside border to inside border measurement when the offsetParent is the <body> and the <body> or <html> element has a visible margin, padding, or border value

            offsetParent, offsetTop, and offsetLeft are extensions to the HTMLelement object

    5.3 Getting an elements top, right, bottom and left border edge offset relative to the viewport using getBoundingClientRect()

        .getBoundingClientRect()
            will get the distances of the BOUNDING EDGE (border) from the viewport starting with the TOP LEFT edge

            it will add the properties:
                .top
                .right
                .bottom
                .left

    5.4 Getting an elements size (border + padding + content) in the viewport
        .getBoundingClientRect()
            also returns a height and width property
                .height
                .width
            
            box sizing! 

    5.5 Getting an elements size (padding + content) in the viewport excluding borders

        return (padding + content)
        .clientHeight
        .clientWidth

    5.6 Getting topmost element in viewport at a specific point using elementFromPoint()

        starting from the top and left of viewport 

        .elementFromPoint(px from top, px from left)

        return the TOPMOST element (z over x priority)

    5.7 Getting the size of the element being scrolled using scrollHeight and scrollWidth 

        .scrollHeight
        .scrollWidth

        gives you the height and width of the node being scrolled 

        note: the element itself ang minemeasure nito hindi yung content na nasa loob nya lalo na kapag smaller sa kanya 

    5.8 Getting and Setting pixels scrolled from the top and left using scrollTop and scrollLeft 

        .scrollTop
        .scrollLeft 

        parang setting the length of the scroll (kung gano kalaki yung pede pang iscroll) 

    5.9 Scrolling an element into view using scrollIntoView()

        pag iniscroll mo siya yung mavview
            select the element inside the scrollable node, 
            then .scrollIntoView(true)

            true is optional because it is the default parameter

            if false is the parameter, it will scroll to the bottom element

CHAPTER 6 - Element Node Inline Styles 

    6.1 Style Attribute (aka element inline CSS properties) Overview 

        .style Property
            returns a CSSStyleDeclaration (array-like), so different styles are indexed

            inline element styles only ang nandito, di kasama ang internal at external styles 

    6.2 Getting, setting, and removing individual inline CSS properties

        <script>

        var divStyle = document.querySelector('div').style;

        //set
        divStyle.backgroundColor = 'red';
        divStyle.border = '1px solid black';
        divStyle.width = '100px';
        divStyle.height = '100px';

        //get
        console.log(divStyle.backgroundColor);
        console.log(divStyle.border);
        console.log(divStyle.width);
        console.log(divStyle.height);

        /*remove
        divStyle.backgroundColor = '';
        divStyle.border = '';
        divStyle.width = '';
        divStyle.height = '';
        */

        </script>

    
        setProperty, getProperty, removeProperty

            <script>

            var divStyle = document.querySelector('div').style;

            //set
            divStyle.setProperty('background-color','red');
            divStyle.setProperty('border','1px solid black');
            divStyle.setProperty('width','100px');
            divStyle.setProperty('height','100px');

            //get
            console.log(divStyle.getPropertyValue('background-color'));
            console.log(divStyle.getPropertyValue('border','1px solid black'));
            console.log(divStyle.getPropertyValue('width','100px'));
            console.log(divStyle.getPropertyValue('height','100px'));

            /*remove
            divStyle.removeProperty('background-color');
            divStyle.removeProperty('border');
            divStyle.removeProperty('width');
            divStyle.removeProperty('height');
            */

            </script>

    6.3 Getting, setting & removing all inline CSS properties 

        using .cssText 
            
            //set using cssText
            divStyle.cssText = 'background-color:red;border:1px solid black;height:100px;width:100px;';
            
            //get using cssText
            console.log(divStyle.cssText);
           
            //remove
            divStyle.cssText = '';

        using .setAttribute, .getAttribute & .removeAttribute

            //set using setAttribute
            div.setAttribute('style','background-color:red;border:1px solid black;height:100px;width:100px;');
            
            //get using getAttribute
            console.log(div.getAttribute('style'));
            
            //remove
            div.removeAttribute('style');

    6.4 Getting an elements computed style (ie. actual styles including any from the cascade) using getComputedStyle()

        eto pwede na pati internal at external 
        return CSSStyleDeclaration rin (read-only)

        eg. 
            //logs rgb(0, 128, 0) or green, this is an inline element style
            console.log(window.getComputedStyle(div).backgroundColor);

            //logs 1px solid rgb(128, 0, 128) or 1px solid purple, this is an inline element style
            console.log(window.getComputedStyle(div).border);

            //logs 100px, note this is not an inline element style
            console.log(window.getComputedStyle(div).height);

            //logs 100px, note this is not an inline element style
            console.log(window.getComputedStyle(div).width);

        getComputedStyle() honors CSS Specificity Hierarchy 
       
        returns rgb colors! kahit ano pang way of declaration niya (eg. hsl, ... )

        shorthand properties are NOT COMPUTED
    
    6.5 Apply and remove css properties on an element using class & id attributes 

        .setAttribute(id/class name, value)
        .removeAttribute(id/classname)

        .classList.add(className)
        .classList.remove(className)

CHAPTER 7 - Text Nodes 

    7.1 Text object overview 

        text in an html document is an instance of the Text() constructors

    7.2 Text object & properties 

        noteworthy properties:
            textContent
            splitText()
            appendData()
            deleteData()
            insertData()
            replaceData()
            subStringData()
            normalize()
            data
            document.createTextNode() (not a property or inherited property of text nodes but discussed in this chapter)

    7.3 White space creates Text nodes

        may text nodes sa whitespaces like returns, spaces, tabs

        eg. 
            <p id="p1"></p>
            <p id="p2"> </p>

            <script>

            console.log(document.querySelector('#p1').firstChild) //logs null
            console.log(document.querySelector('#p2').firstChild.nodeName) //logs #text

            </script>

    7.4 Creating and Injecting Text Nodes 

        document.createTextNode('text'); 

        (like createElement)

        then append

        we can also create text node programatically (without appending yet) 

    7.5 Getting a Text node value with .data or nodeValue 

        eg: 
            <p>Hi, <strong>cody</strong></p><body>

            <script>

            console.log(document.querySelector('p').firstChild.data); //logs 'Hi,'
            console.log(document.querySelector('p').firstChild.nodeValue); //logs 'Hi,'

            </script>

        note: 
            getting the length, just add .length after
    
    7.6 Manipulating Text nodes with appendData(), deleteData(), insertData(), replaceData(), subStringData()

        methods of CharacterData (where Text nodes inherit)
            appendData('text')
            deleteData(indexStart, numberOfElementsToBeRemoved)
            insertData(indexStart, 'text')
            replaceData(indexStart, numberOfElementsToBeRemoved, 'textReplacement')
            subStringData(indexStart, numberOfElementsToBeExtracted)

        same methods can beused by comment nodes 
    
    7.7 When multiple sibling Text nodes occur 


            <p>Hi, <strong>cody</strong> welcome!</p>

            element, text, element, text, text 

            if programatically done: 

                creating two text nodes even if it is like connecting to each other, will result to TWO text nodes (in this example: 'Hi Cody')

                var pElementNode = document.createElement('p');
                var textNodeHi = document.createTextNode('Hi ');
                var textNodeCody = document.createTextNode('Cody');

                pElementNode.appendChild(textNodeHi);
                pElementNode.appendChild(textNodeCody);

                document.querySelector('div').appendChild(pElementNode);

                console.log(document.querySelector('div p').childNodes.length); //logs 2​

    7.8 Remove markup and return all child Text nodes using textContent
                 
            .textContent
                return all child text nodes even if they are not sunod-sunod 
                return will be a concatenated string of all text nodes


            modifying .textContent = 'text' 
                will remove all the child nodes (including element nodes) 
                then replacing it with a single text node of 'text'

        note: 
            textContent returns null when used in document or doctype node

            textContent returns contents from <script> and <style> elements 

    7.9 Difference between textContent & innerText 

        innerText is aware of CSS. styles are applied including the hidden. it will not return the hidden text

        innerText will trigger a reflow or recalculation based on CSS 

        innerText ignores text nodes in <style> and <script>

        innerText will normalize the text that is returned 
        textContent return exactly what is in the document (including whitespaces, carriage returns and line breaks)

        innerText is non-standard and browser specific (not suitable for Firefox)

    7.10 Combine sibling Text nodes into one text node using normalize()

        creating two text nodes programatically can result to different child text nodes after appending. to concatenate two text nodes (without element nodes in between), we use parentNode.normalize(). then it will result to one text node nalang 

    7.11 Splitting a text node using splitText()
            kung ang normalize ay combining text nodes, eto naman ay splitting text nodes into two

                .splitText(startIndex) (kasama siya)

                eg.

                    <p>Hey Yo!</p>

                    <script>

                    //returns a new text node, taken from the DOM
                    console.log(document.querySelector('p').firstChild.splitText(4).data); //logs Yo!

                    //What remains in the DOM...
                    console.log(document.querySelector('p').firstChild.textContent); //logs Hey

                    </script>

CHAPTER 8 - DocumentFragment Nodes 

    8.1 DocumentFragment object overview 
            provides a light weight document DOM that is external to the live DOM tree 

            empty document template acting like the live DOM tree, but only lives in memory and its child nodes can easily be manipulated then appending to the live DOM

            parang other version without working on the original version

    8.2 Creating DocumentFragment's using createDocumentFragment()
            
            document.createDocumentFragment();

            eg.
                <script>

                var docFrag = document.createDocumentFragment();

                ["blue", "green", "red", "blue", "pink"].forEach(function(e) {
                    var li = document.createElement("li");
                    li.textContent = e;
                    docFrag.appendChild(li);
                });

                console.log(docFrag.textContent); //logs bluegreenredbluepink

                </script>

            using documentFragment is efficient when it comes to inject the documentFragment into live node structures 

            difference between documentFragment and createElement

                document fragment may contain any kind of node

                document fragment itself is not added to the DOM when you append a fragment. the contents of the nodes are. in createElement, the element itself is part of the appending

                after transfering to the DOM, document fragment is no longer in memory in the place you created it. whereas in createElement, it is. 

    8.3 Adding a DocumentFragment to the live DOM 

            .appendChild(documentFragment)
            .insertBefore(documentFragment, referenceNode)

            eg.

                <ul></ul>

                <script>

                var ulElm = document.queryselector('ul');
                var docFrag = document.createDocumentFragment();

                ["blue", "green", "red", "blue", "pink"].forEach(function(e) {
                    var li = document.createElement("li");
                    li.textContent = e;
                    docFrag.appendChild(li);
                });

                ulElm.appendChild(docFrag);

                //logs <ul><li>blue</li><li>green</li><li>red</li><li>blue</li><li>pink</li></ul>
                console.log(document.body.innerHTML);

            basta ang nilalagay nya lang ay yung contents nya! (pinakacontent kasa mga tags)

    8.4 Using innerHTML on a documentFragment 

        you cannot use directly an innerHTML property in docFrag because it is a document like node

            eg.

                <script>

                //create a <div> and document fragment
                var divElm = document.createElement('div');
                var docFrag = document.createDocumentFragment();

                //append div to document fragment
                docFrag.appendChild(divElm);

                //create a DOM structure from a string
                docFrag.querySelector('div').innerHTML = '<ul><li>foo</li><li>bar</li></ul>';

                //the string becomes a DOM structure I can call methods on like querySelectorAll()
                //Just don't forget the DOM structure is wrapped in a <div>
                console.log(docFrag.querySelectorAll('li').length); //logs 2

                </script>

        when appending a DOM structure using documentFragment and <div>, you'll want to append the structure skipping the injection of the <div> 

            eg.
                <script>

                //create a <div> and document fragment
                var divElm = document.createElement('div');
                var docFrag = document.createDocumentFragment();

                //append div to document fragment
                docFrag.appendChild(divElm);

                //create a DOM structure from a string
                docFrag.querySelector('div').innerHTML = '<ul><li>foo</li><li>bar</li></ul>';

                //append, starting with the first child node contained inside of the <div>
                document.querySelector('div').appendChild(docFrag.querySelector('div').firstChild);

                //logs <ul><li>foo</li><li>bar</li></ul>
                console.log(document.querySelector('div').innerHTML);

                </script>

        note:
            DOMParser
                parse HTML stored in a string into a DOM Document
                supported only in OPERA and FIREFOX
            
            domify 
                if you want a stand along HTML to DOM 

    8.5 Leaving a fragments containing nodes in memory by cloning
            .cloneNode(true)

            eg. 

                <script>

                //create ul element and document fragment
                var ulElm = document.querySelector('ul');
                var docFrag = document.createDocumentFragment();

                //append li's to document fragment
                ["blue", "green", "red", "blue", "pink"].forEach(function(e) {
                    var li = document.createElement("li");
                    li.textContent = e;
                    docFrag.appendChild(li);
                });

                //append cloned document fragment to ul in live DOM
                ulElm.appendChild(docFrag.cloneNode(true));

                //logs <li>blue</li><li>green</li><li>red</li><li>blue</li><li>pink</li>
                console.log(document.querySelector('ul').innerHTML);

                //logs [li,li,li,li,li] 
                console.log(docFrag.childNodes);

                </script>

CHAPTER 9 - CSS Style Sheets & CSS rules 

    9.1 Overview 

        style sheet 
            added either by:
                HTMLLinkElement node (external link)
                HTMLStyleElement node (internal style)

    9.2 Accessing all style sheets (i.e. CSSStylesheet objects) in DOM 

            document.styleSheets
                returns an arraylike collection (CSSStyleSheet) where stylesheets are indexed 

                indexes are based on top down declaring of stylesheet 

                eg.
                    <link href="http://yui.yahooapis.com/3.3.0/build/cssreset/reset-min.css" rel="stylesheet" type="text/css">

                    <style>
                    body{background-color:red;}
                    </style>

                    </head>
                    <body>

                    <script>

                    console.log(document.styleSheets.length); //logs 2
                    console.log(document.styleSheets[0]); // the <link>
                    console.log(document.styleSheets[1]); // the <style>


            .sheet Property
                same as accessing the stylesheets using indexes 

            eg. 
                //get CSSStylesheeet object for <link>
                console.log(document.querySelector('#linkElement').sheet); //same as document.styleSheets[0] 

                //get CSSSstylesheet object for <style>
                console.log(document.querySelector('#styleElement').sheet); //same as document.styleSheets[1]

    9.3 CSSStyleSheet properties and methods 

            properties and methods available:

                disabled
                href
                media
                ownerNode
                parentStylesheet
                title
                type
                cssRules
                ownerRule
                deleteRule
                inserRule

            note: 
                href, media, ownerNode, parentStylesheet, title, and type are read only properties. you cant set its value using these properties 

    9.4 CSSStyleRule overview 

            represents each CSS rule contained in a style sheet 
            interface to the CSS properties and values attached to a selector

            also an array-like collection 

            eg.

                <style id="styleElement">
                body{background-color:#fff;margin:20px;} /*this is a css rule*/
                p{line-height:1.4em; color:blue;} /*this is a css rule*/
                </style>

                </head>
                <body>

                <script>

                var sSheet = document.querySelector('#styleElement');

                console.log(sSheet.cssRules[0].cssText); //logs "body { background-color: red; margin: 20px; }"

                console.log(sSheet.cssRules[1].cssText); //logs "p { line-height: 1.4em; color: blue; }"

                </script>

    9.5 CSSStyleRule properties and methods

            properties and methods available:

                cssText
                parentRule
                parentStylesSheet
                selectorText
                style
                type

    9.6 Getting a list of CSS Rules in a style sheet using CSSRules 

            provides all CSSRules in a SPECIFIC stylesheet
                meaning you first select the stylesheet (external or internal) then you count the CSSRules inside it. you cannot count the total rules combining external and internal

                eg. 

                    <script>
                    
                    //selecting internal stylesheet
                    var sSheet = document.querySelector('#styleElement').sheet;

                    //array like list containing all of the CSSrule objects repreesenting each CSS rule in the style sheet
                    console.log(sSheet.cssRules);

                    console.log(sSheet.cssRules.length); //logs 2

                    //rules are index in a CSSRules list starting at a 0 index
                    console.log(sSheet.cssRules[0]); //logs first rule
                    console.log(sSheet.cssRules[1]); //logs second rule

                    </script>

    9.7 Inserting & deleting CSS rules in a stylesheet using .insertRule() and .deleteRule() 

        programatically manipulate CSS rules in a stylesheet (same as pushing in an array)

        .insertRule('rule', index)
        .deleteRule(index)

    
        note: 
            inserting and deleting rule is hard and not a common practice. it is much simpler working on the ORIGINAL CSS AND HTML file before they are serve to a client

            classes can be used in modifying styles (has already predefined rules)

    9.8 Editing the value of a CSSStyleRule using the .style Property

            1. select the rule using indexes
            2. add .style.rule = 'value';
        
        eg. 
            <script>

            var styleSheet = document.querySelector('#styleElement').sheet;

            //Set css rules in stylesheet
            styleSheet.cssRules[0].style.color = 'red';
            styleSheet.cssRules[1].style.color = 'purple';

            //Get css rules
            console.log(styleSheet.cssRules[0].style.color); //logs 'red'
            console.log(styleSheet.cssRules[1].style.color); //logs 'purple'

            </script>

        
    9.9 Creating a new internal CSS style sheets 

            1. create an element style 
            2. create an innerHTML on style Element3
            3. append inside <head>

    9.10 Programatically adding external style sheets to an HTML document 

            1. create element link 
            2. setAttributes of rel, type, href, and id 
            3. append inside <head> 

    9.11 Disabling/Enabling style sheets using disabled property 

            1. select stylesheet 
            2. add .disabled = true

        note: you cannot add disabled as an attribute to link or style. html document will fail 

CHAPTER 10 - JavaScript in the DOM 

    10.1 Inserting and executing Javascript overview 
            internal JS (<script>) and external JS (<script src='.js'>)
        
        note: 
            not considered a modern practice but doable:
                -set attribute of JS event handler
                -set attribute href with a value of 'javascript: code to execute'

            if external JS and internal JS is on the same <script> tag, internal JS will be ignored 

            do not do self closing scripts 

            <script> optional attributes 
                async
                charset
                defer
                src
                type 

            Internal JS produces text nodes which can be extracted using innerHTML and textContent. However, appending a new text node made up of JS codes after DOM has already loaded, will not execute the code. It simply replaces the text (so parang as comment lang siya)

            if JS code contains string '</script>' you need to escape / so that the parser does not think this is the real closing tag. 

            <\/script>

    10.2 JavaScript is parsed synchronously by default

            js script can block the parsing of DOM so its best to add script tag before the closing tag of body (after DOM has parsed)

    10.3 Defering the downloading and execution of external JavaScript using defer

            adding defer attribute to script tag so it will not block the downloading of DOM / parsing of the whole HTML 

            javascript will be parsed after

        note: 
            defer is Boolean

            using defer, document.write() is not being used in the JS that will be defered 
    
    10.4 Asynchronously downloading and executing external JavaScript files using async 

            async attribute
                override the sequential blocking nature of <script> 
                JS files are loaded in parallel (simultaneously) with DOM 

            note: 
                IE9 has no support for this 

                major drawback: JS files potentially get parsed out of the order they are included in the DOM 

                async is Boolean 

                using async, document.write() is not being used in the JS that will be defered 

                async will trump defer if both are used in the same script element 

    10.5 Forcing asynchronous downloading and parsing of external JavaScript using dynamic <script> 

            eg. 
                <script>
                var underscoreScript = document.createElement("script"); 
                underscoreScript.src = "http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.3.3/underscore-min.js"; 
                document.body.appendChild(underscoreScript);
                </script>

            note:
                major drawback: files potentially get parsed out of order 

    10.6 Using the onload call back for asynchronous <script>'s so we know when it's loaded

        .onload 
            load event handler that will execute once an external JS file has been loaded and executed 


        note:
            using onload event is only the tip of the iceberg. you also have use of onerror, load, and error 

    10.7 Be mindful of <script>'s placement in HTML for DOM manipulation

            place before closing tag of body 

    10.8 Getting a list of <script>'s in the DOM 

            document.scripts
                provides a list (array-like again) of all the scripts currently in the DOM 

CHAPTER 11 - DOM Events 

    11.1 DOM events overview 
            Event 
                pre-defined or custom moment in time that occurs in relationship with an element in the DOM, the document object or the window object

                these moments can be initiated by that state of the UI, state of the environment that is running the JS program, or the state of the program itself 

            Setting up events. 3 methods:
                1. inline attribute event handlers 
                2. property event handlers 
                3. addEventListener() method 

                eg. 

                    <!-- inline attribure event handler pattern -->
                    <body onclick="console.log('fire/trigger attribure event handler')">

                    <div>click me</div>

                    <script>
                    var elementDiv = document.querySelector('div');

                    // property event handler pattern
                    elementDiv.onclick = function(){console.log('fire/trigger property event handler')};

                    //addEventListener method pattern
                    elementDiv.addEventListener('click',function(){console.log('fire/trigger addEventListener')}, false);
                    </script> 

                downside of property event handlers: 
                    eg. 

                        // property event handler 
                        elementDiv.onclick = function(){console.log('I\'m first, but I get overidden/replace')};

                        //overrides/replaces the prior value
                        elementDiv.onclick = function(){console.log('I win')};

        Notes: 
            Element nodes & window object support inline, property event handlers, and addEventListener() method 

            Document node supports property handlers, and addEventListener()

    11.2 DOM event types 
            http://domenlightenment.com/#11.2 
            check event types here 

            UI events
                load
                unload
                abort
                error
                resize
                scroll
                contextmenu

            Focus events 
                blur
                focus
                focusin
                focusout 

            Form events 
                change
                reset
                submit
                select 

            Mouse events 
                click
                    mousedown>mouseup>click
                dblclick
                mousedown
                mouseenter
                    parang hover but it does not bubble 
                mouseleave
                    hover out and does not bubble
                mousemove
                mouseout 
                    like mouseleave but bubbles and cancellable
                mouseup
                mouseover 
                    like mouseenter but bubbles and cancellable

            Wheel Events
                wheel (or mousewheel)
                    any axis rotation

            Keyboard Event
                keydown
                    sent for any key
                keypress 
                    like keydown but the key normally produces a character value
                keyup 
                    always follows keydown and keypress 

            Touch Events 
                touchstart
                    user touch a surface
                touchend 
                    removes a touch point or touch point leave the surface of the screen (touch drag out)
                touchmove 
                    moves a touch point along the touch surface (dragging)
                touchenter 
                    touch point MOVES into an interactive area 
                touchleave
                    touch point MOVES OFF into an interactive area 
                touchcancel
                    disrupted touch point 

            note: supported on IOS, Android, Blackberry or browsers that can switch on touch 

            Window, <body>, and frame specific events 
                afterprint 
                beforeprint
                beforeunload
                hashchange
                    changes to the portion of URL that follows a number sign #
                message
                    user sends a cross-document message
                    message sent from a Worker with postMessage
                offline
                online
                pagehide
                pageshow
            
            Document specific events
                readystatechange
                DOMContentLoaded
                    webpage has been parsed but before resources have been fully downloaded 
                
            Drag events 
                drag 
                    continously dragging (on process) (sourceobject)
                dragstart
                    starts to drag (before drag) (sourceobject)
                dragend
                    releases the mouse after drag (sourceobject)
                dragenter
                    user drags the object to a valid drop target (targetelement)
                dragleave
                    user moves the mouse out of a valid drop target during drag operation (targetobject)
                dragover
                    like drag but target element 
                drop 
                    mouse button released during a drag-and-drop operation 
                
        Note: these are the common types, there are more types in HTML5 like media events for <video> and <audio>

        copy,cut, and textinput event are not defined by DOM 3 events or HTML5

        Use mouseenter and mouseleave instead of mouseover and mouseout. Firefox, Chrome and Safari haven't added mouseover and mouseout yet. 

    11.3 The event flow 

            capture phase
                parent to child (in)
            bubbling phase 
                child to parent (out)
            or both 

        Typically, events are assumed to be invoked during the bubbling phase because capture phase is unreliable back then

        notes:
            modern browsers DO support the use of the capture phase. one could intercept an event before it occurs on the event target 

            eventPhase property
                which phase an event is invoked in
                1 - capture phase
                2 - target phase
                3 - bubbling phase

    11.4 Adding event listeners to Element nodes, window object, and Document object

            .addEventListener('event type', 'function to be invoked', 'boolean')

                event type do not contain the prefix on-, unlike in property event handlers 

                boolean parameter indicates if the event should be fired during the capture phase or bubbling phase of the event flow 
                    true - capture
                    false - bubbling

            Note:
                typically, a developer wants to fire during the bubbling phase. so the third parameter is always false. we can also leave the third parameter as its default is false 

                addEventListener() method can be used on the XMLHttpRequest object

    11.5 Removing event listeners

            .removeEventListener('event type', 'function invoked', 'boolean') 
                remove event listeners if the original listener was not added using an ANONYMOUS function.

                function invoked can't be an anonymous function!!! 
                it's important to use named functions
                parameters of .remove must be exactly the same as what you passed in .add 

    11.6 Getting event properties from the event object 

            event object also provides these methods:
                .stopPropagation()
                .stopImmediatePropagation()
                .preventDefault()

    11.7 The value of this when using addEventListener()

        this Property
            reference to the node or object the event is attached to.
            kung san lang nakakabit yung event, kahit pumindot ka pa ng child element nya, sya parin ang lalabas 

        event.currentTarget
            reference to the node or object the event is attached to. same as this property lang 

    11.8 Referencing the target of an event and not the node or object the event is invoked on 

        event.target 
            reference to the node or object that the event ORIGINATED. not the event is attached per se. 

            document.body.addEventListener('click',function(event){
            //when the <div> is clicked logs '<div>' because the <div> was the target in the event flow not the <body>
            console.log(event.target); 
            },false);

    11.9 Cancelling default browser event using preventDefault()

            .preventDefault()
                prevents the default event of an element. eg anchors navigating to url, checkboxes having ticks when clicked, text field typing text but the event will STILL FLOW. it will not stop 

            
        Notes:
            preventDefault() methods does not stop events from propagating (i.e. bubbling or capture phases)

            return false
                provide at the end of the body of the event listener to call preventDefault() 
            
            cancelable Property
                event listener functions boolean property
                respond to preventDefault() and cancelling default behavior 
                sila lang pwedeng lagyan ng preventDefault()

            defaultPrevented 
                event lister function property 
                return true if preventDefault() has been invoked in bubbling phase 

    11.10 Stopping the event flow using stopPropagation()

            .stopPropagation() 
                stop the capture and bubble event flow but any events directly attached to the node or object will still be invoked. 

                does not prevent default events 
    
    11.11 Stopping the event flow as well as other like events on the same target using stopImmediatePropagation()

            .stopImmediatePropagation()
                stop the event flow as well as any other like events attached to the event target 

            eg.
                //first event attached
                document.querySelector('div').addEventListener('click',function(){
                console.log('I get invoked because I was attached first');
                },false);

                //seond event attached
                document.querySelector('div').addEventListener('click',function(event){
                console.log('I get invoked, but stop any other click events on this target');
                event.stopImmediatePropagation();
                },false);

                //third event attached, but because stopImmediatePropagation() was called above this event does not get invoked
                document.querySelector('div').addEventListener('click',function(){
                console.log('I get stopped from the previous click event listener');
                },false);

                //notice that the event flow is also cancelled as if stopPropagation was called too
                document.body.addEventListener('click',function(){
                console.log('What, denied from being invoked!');
                },false);

            does not prevent default events 
    
    11.12 Custom Events 
        creating:
            document.createEvent('customEvent')

        setup the details:
            .initCustomEvent('event', bubble?, cancellable?, pass values to event.detail)

        invoking custom event
            .dispatchEvent('event') 

        IE9 requires the 4th parameter on initCustomEvent

    11.13 Simulating/Triggering mouse events 

            eg. 
                var divElement = document.querySelector('div');

                //setup click event that will be simulated
                divElement.addEventListener('click',function(event){
                    console.log(Object.keys(event));
                },false);

                //create simulated mouse event 'click'
                var simulateDivClick = document.createEvent('MouseEvents');

                /*setup simulated mouse 'click'
                initMouseEvent(type,bubbles,cancelable,view,detail,screenx,screeny,clientx,clienty,ctrlKey,altKey,shiftKey,metaKey,button,relatedTarget)*
                simulateDivClick.initMouseEvent('click',true,true,document.defaultView,0,0,0,0,0,false,false,false,0,null,null);

                //invoke simulated clicked event
                divElement.dispatchEvent(simulateDivClick);

    11.14 Event Delegation 

            programmatic act of leveraging the event flow and a single event listener to deal with multiple event targets

            side-effect: kahit wala pa DOM nag rerespond na sa events 

            note: event delegation is ideal when dealing with a click, mousedown, mouseup, keydown, keyup, and keypress 

Chapter 12 - Creating dom.js - a wishful jQuery inspired DOM library for modern browsers
    12.1 dom.js overview 

            jQuery like DOM library (custom made)

    I will skip this chapter. Balik nalang tayo next time. 

    

PLAIN JS - additional notes

    for looping on getElementsByClassName() 
        updating a class means deleting the current class then adding the new class. that will leave us to original length - 1, then go back to original length

        but querySelectorAll() is much more viable
    
    referenceElement.closest('findElement')
        get the first element that matches the selector by testing the element itself and travsersing up through its ancestors in the DOM tree 
    
    Unwrap a DOM element
        move all children out of the parent element (use .insertBefore) 
        then remove parentNode 

    Empty element's content
        parentNode.innerHTML = ''

    .insertBefore, .insertAfter, .insertAdjacentHTML

w3schools - additonal notes 

     this is for clearer syntax (with parameters):
     https://www.w3schools.com/js/js_htmldom_document.asp


    3 different parts of W3C DOM standard 
        -Core DOM - standard model for all document types 
        -XML DOM - standard model for XML documents 
        -HTML DOM - standard model for HTML documents 
    
    property - value 
    method - action 

    Date() - returns the date

    document.write(content) - use to write directly where you put the <script>
                            - never use after document has loaded because it may overwrite the document 

    JS Form Validation 
        we can use .value property and test it
        
        then add an event submit with your named function validateForm()

        required attribute 
            if field is empty, prevents form from submitting 

    2 Types of Data Validation
        Server side Validation
            perform by web server, after input has been sent to the server 
        
        Client side validation 
            perform by web browser, before input is sent to a web server 

    Constraint Validation HTML input attributes: 
        https://www.w3schools.com/html/html_form_attributes.asp

    Constraint Validation CSS Pseudo Selectors 
        https://www.w3schools.com/css/css_pseudo_classes.asp

    addEventListener(event, function, useCapture);
        useCapture values:
            true - capturing 
            default/false - bubbling 

JS DOM Crash Course from Traversy Media
    console.dir(target)
        lists as directory. you can see all what you can access from the target 

    console.log(target.all)
        you can see the array(HTML Collection) of nodes of the target. complete with their index

    document.forms - return array of all forms 
    document.links - return array of all links 
    document.images - return array of all images 

    tip: console.log or dir every target so you can access the collection of properties/items/indexes under them

    additional CSS selectors (pseudoclasses)
        :last-child
        :nth-child(indexNum)
        :nth-child(odd)
        :nth-child(even)
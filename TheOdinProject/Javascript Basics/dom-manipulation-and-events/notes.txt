DOM
    Document Object Model 
    tree-like representation of the contents of a webpage
    a tree of 'nodes'

'selectors'
    used to target the nodes you want to work with
    
    CSS style selectors and relationship properties to target the nodes you want
        eg.  <div class="display"></div>
                    div.display
                    .display
                    #container > .display
                    div#container > div.display

    relational selectors 
        firstElementChild or lastElementChild etc. 
    
        eg. container.firstElementChild

DOM Methods 
    use to manipulate our webpage with Javascript

    Query Selectors 
        -element.querySelector(selector) returns a reference to the first match of selector

        -element.querySelectorAll(selectors) returns a “nodelist” containing references to all of the matches of the selectors
            -return value of this is NOT AN ARRAY even though it may look like an array
            -return value is a 'nodelist'
            -big difference is array methods are not all available in a nodelist 
                -a solution for this is to convert the nodelist into an array

                    syntax:
                        Array.from()

                -or a spread operator
                        (...arrayName)

    Element Creation
        Syntax:
            document.createElement(tagName, [options])
        
        creates a new element of tag type tagName
        [options] means you can add some optional parameters to the function

        eg. 
            const div = document.createElement('div');

        this does not put your new element into the DOM 
        creates only, store in the memory
        so you can manipulate first the element before placing it on the page
            adding styles,classes, ids, text, etc
        
    Append Elements
       method for placing the element you created and manipulated 

        parentNode.appendChild(childNode)
            appends childNode as the last child of parentNode
        
        parentNode.insertBefore(newNode, referenceNode)
            inserts newNode into parentNode before the referenceNode

    Remove Elements
        parentNode.removeChild(child)
            removes the child from the parentNode on the DOM and returns a reference to child

    Altering Elements
        containing a created element in a variable so we can alter/manipulate it easier
            const div = document.createElement('div')

        Adding inline style
            eg.
                //using JS property
                div.style.color = 'blue'

                //using CSS property
                div.style.cssText = 'color: blue; background: white';

                //using CSS property
                div.setAttribute('style', 'color: blue; background: white');

                //using CSS property
                div.style['background-color']  

        We can remove inline style by setting the value to an empty string
            eg. 
                div.style.color = '';
                div.style.cssText = '';
                div.setAttribute('');   

        Property names here does not contain the usual kebab case in CSS. and because we are in Javascript, we convert the kebab to a camelCase. just remove hyphens and apply camelCase
            in the case that a property name is a Javascript keyword (reserved words), the property name is prefixed with css
                eg. cssText, cssFloat

        Shorthand properties are also available
        
        Do not forget units! 

        Full list of CSS Property to Javascript Property
        http://domenlightenment.com/#6.2


        Other methods for adding and removing

            we can also use .setProperty(property, value) for adding
                where property is in the syntax of CSS (kebab-style)

                eg. divStyle.setProperty('background-color', 'red')

            .getPropertyValue(property) for reading
                getting the current value of the property
                
                eg. divStyle.getPropertyValue('background-color')

            .removeProperty(property) for deleting 

                eg. divStyle.removeProperty('background-color')

            Other methods so we can use css property syntax:
            https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration

    Editing Attributes
        .setAttribute('attribute', 'value')
            if property already exists, it updates its value
            if it still does not exists, it creates the property with the corresponding value 
            value is always a string even if it is a measurement

        .getAttribute('property')
            reads the value of the specified property

        .removeAttribute('property')
            remove the property 
        
        IDL Attribute
            Interface Definition Language Attribute
            Javascript properties
            not always strings 

            eg. input.maxLength = numberValue (expects a number)

            when you put a string eg "200", it will convert it into number (JS conversion)

        Boolean Attribute 
            eg. required, readonly, disabled 
            
            if a boolean attribute is present, its value is true 
            if it is not present, its value is false 

            to be clear, boolean attributes dont need values to be indicated

            eg:
                <input checked></input>             //checked is true
                <input></input>                     //checked is false 
                <input checked="false"></input>     //checked is true since it is indicated! 

Working with classes 
    div.classList.add(className)
        adds class to your div 

    div.classList.remove(className)
        remove the class from div 

    div.classList.toggle(className)
        if your div doesnt have this className specified, it will add it
        if your div has it, it will remove it

    note: it is often the standard (and cleaner) to use toggle because it uses both functions already

Adding text content 
    div.textContent = ''
        create a text node containing the message, and insert it in the div 

Adding HTML content
    div.innerHTML = '<span>Message</span>'
        renders the HTML inside div
        nag aadd sa pinakaHTML! it can modify the main HTML!
        it can inject JS on a page! some scripts can get sensitive information using this innerHTML! 

        just change it .innerText

        if you will use this innerHTML, make sure that no user input can make it through without being sanitized

important note: textContent is preferable because adding HTML content can create security risks if misused.

Keep in mind: JS does not alter your HTML (original file), but the DOM only! 

Where to put the JS External File linking? 
    put it before the closing tag of the body so that all the HTML will load first thus creating the DOM

    if we put it in the head tag, JS is read first, thus no manipulation will be done in the DOM since it is not created/loaded yet 

    there is an easy fix if there is an instance that a js file is in the head tag
        include a defer attribute in the script tag
            <script src='./js-file.js defer></script>

            defer makes the js file load after the HTML is parsed and DOM is created

Events 
    actions that occur on your webpage
    JS can make our webpage listen and react to events


3 ways
    Method 1
        direct attaching of functions to the HTML Elements 

        <button onclick="alert('Hello World')">Click Me</button>

        less ideal because we're cluttering our HTML
        we can only have 1 'onclick' event per element 

    Method 2
        setting on_event_ property on the DOM object in your JavaScript

        <!-- the HTML file -->
        <button id="btn">Click Me</button>

        // the JavaScript file
        const btn = document.querySelector('#btn');
        btn.onclick = () => alert("Hello World");

        problem again, we can only have 1 'onclick' event per element

    Method 3
        <!-- the HTML file -->
        <button id="btn">Click Me Too</button>  

        // the JavaScript file
        const btn = document.querySelector('#btn');
        btn.addEventListener('click', () => {
        alert("Hello World");
        });

        we have separation of html and JS file 
        we also have allowed multiple event listeners

    Note: all three methods can be used with named functions

    <!-- the HTML file -->
    <!-- METHOD 1 -->
    <button onclick="alertFunction()">CLICK ME BABY</button>

    //JS FILE 
    function alertFunction() {
    alert("YAY! YOU DID IT!");
    }

    // METHOD 2
    btn.onclick = alertFunction;

    // METHOD 3
    btn.addEventListener('click', alertFunction);

    RECOMMENDED! using named function can clean up your code
    especially if you are reusing the function

Accessing more information about the event: 
eg. 
    btn.addEventListener('click', function (e) {
    console.log(e);
    });

    parameter e in the function is an object that references to the event itself

    e.target
        provide information for the target DOM node that was clicked(event)

    you can manipulate the DOM of the target (self) using this
        e.target.style.background = "blue"

Attaching listeners to the groups of node
    use querySelectorAll('selector')
    then treat the nodelist as an array 

    const buttons = document.querySelectorAll('button')

    buttons.forEach( (button) => {
        button.addEventListener('click', ()=> alert(button.id))
    }

    HTML DOM Event Object Reference
    https://www.w3schools.com/jsref/dom_obj_event.asp

to make up an attribute name put it here so html will still read it 

    data-madeUpAttribute = ''

Bubbling
    triggering a nested element will trigger all its parent up to the root element 

    because it captures all events from the parent up to the nested child element, then it triggers/bubble up from the child to the parents 

Eloquentjavascript.net

talksAbout function
    talksAbout(target, query)

Finding Elements 

.getElementByTagName('tagname')[index]

.getElementById('id name')
    no index since isa lang ang id name 

.getElementByClassName('class name')[index]


Changing the Document 

document.parentNode.appendChild(childNode)

document.parentNode.insertBefore(newChildNode, siblingNode)
    works best for arrays or nodelists 

document.parentNode.replaceChild(newChildNode, siblingNode)

Creating Nodes 

    Text Nodes
        document.createTextNode

    Array.from(nodelistName) 
        to create a real array and use all methods of an array

Attributes 
    .setAttribute('attribute','value')
    .getAttribute('attribute')

    prefix 'data-' for all made up attributes so that it will not conflict with predefined attributes 

Layout
    offsetWidth and offsetHeight
        gives you the space the element takes up in pixels
    
    clientWidth and clientHeight
        gives you the size of the space inside the element ignoring the border width 

    getBoundingClientRect
        returns an object with top, bottom, left, and right properties
        pixel positions of the sides of the element relative to the top left of the screen 

        for relative to the whole document, you must add the current scroll position 
            pageXOffset and pageYOffset

Positioning and Animating 
    Positions
        static
            -sits in a normal place
        relative
            -top and left style properties can be used to move it relative to that normal place
        absolute
            -element is removed from the normal flow
            -does not take up space and may overlap with other elements 
            -top and left properties can be used to absolutely position it relative to the top-keft corner of the nearest enclosing element whose position property isnt static

    requestAnimationFrame
        schedule the animate function to run whenever the browser is ready to repaint the screen
        
        lets browsers know that we are done for now and it can go ahead and do the things that browsers fo

    note: using numbers without units will result in the style being ignored. (except if your number is 0)


EVENT HANDLERS
    .addEventListener('event', functionToBeDoneAfterEvent)

EVENTS AND DOM NODES
    .removeEventListener('event', functionOfAddEventListener)

    parameters of add event and remove event should be the same! 

    so it is best to have a named function for the second parameter of .addEventListener so that we can easily remove the event lister of an object

EVENT OBJECT
    this is like the keydown property (where we have many unicode numbers associated per key) 

    eg.
    <button>Click me any way you want</button>
    <script>
    let button = document.querySelector("button");
    button.addEventListener("mousedown", event => {
        if (event.button == 0) {
        console.log("Left button");
        } else if (event.button == 1) {
        console.log("Middle button");
        } else if (event.button == 2) {
        console.log("Right button");
        }
    });
    </script>

PROPAGATION
    (this is like bubbling)
    from the node where it happened to that node’s parent node and on to the root of the document

    .stopPropagation() method
        this is to prevent propagating up/bubbling up

    using target property
        use target property if there are instances where there are many similar elements that needs a stopPropagation. listen from the parentNode then target the childNodes of the same element

        eg. 

            <button>A</button>
            <button>B</button>
            <button>C</button>
            <script>
            document.body.addEventListener("click", event => {
                if (event.target.nodeName == "BUTTON") {
                console.log("Clicked", event.target.textContent);
                }
            });
            </script>

DEFAULT ACTIONS
    eg: pressing down arrow will scroll page, right-clicking can get context menu, clicking a link will redirect you


    .preventDefault() method

        if the handler doesn't want to call before the default behavior takes place, use this

        to implement own keyboard shortcutes, context menus...

        to interfere with the behavior that users expect 

    eg. Preventing redirection of a link

        <a href="https://developer.mozilla.org/">MDN</a>
        <script>
        let link = document.querySelector("a");
        link.addEventListener("click", event => {
            console.log("Nope.");
            event.preventDefault();
        });
        </script>

    Depending on the browser, some default actions cannot be prevented like ctrl+w for chrome

KEY EVENTS
    'keydown' event - pressed
    'keyup' event - released 

    take note of this: for key holding, it is keydown event that is repeating! 

    for combination of keys: 
        .shiftKey
        .ctrlKey
        .altKey
        .metaKey (for mac) 

        && event.shiftKey 

    tabindex property   
        for focusing of DOM nodes
        just like in visual basic 

POINTER EVENTS 
    2 ways to point at things in the screen
        1. mice (mouse, touchpads and trackballs)
        2. touchscreens 

    MOUSE CLICK 
        'mousedown', 'mouseup' same as keydown and keyup
        DOM nodes that are immediately below the mouse pointer when the event occurs 

        after mouseup event, a click event happens:
            get most speciic node that contained both the press and the release of mouse
            
            eg. mouse down on one paragraph, mouse up on another paragraph, both paragraph will trigger click event
    
        'dblclick' - double click event 
            two clicks happen close together 

        clientX and clientY
            to locate where the mouse event happened 
            in pixels
            origin: top left corner of screen 

        pageX and pageY
            origin: top left corner of the WHOLE document
        
        eg. (parang etch-a-sketch to)

        <style>
        body {
            height: 200px;
            background: beige;
        }
        .dot {
            height: 8px; width: 8px;
            border-radius: 4px; /* rounds corners */
            background: blue;
            position: absolute;
        }
        </style>
        <script>
        window.addEventListener("click", event => {
            let dot = document.createElement("div");
            dot.className = "dot";
            dot.style.left = (event.pageX - 4) + "px";
            dot.style.top = (event.pageY - 4) + "px";
            document.body.appendChild(dot);
        });
        </script>

MOUSE MOTION 
    'mousemove' - everytime mouse pointer moves 

    used to track position of mouse
    useful for mouse dragging functionality 

    .buttons property
        tells us if buttons are currently held down
            0 - not held down
            1 - left button held down 
            2 - right button held down 
            3 - both left and right held down 
            4 - middle held 

    .button property
        tells us the button doing the event
            0 - left button
            1 - middle button 
            2 - right button 

TOUCH EVENTS 
    'touchstart' event 
        finger touch screen 

    'touchmove'
        move while touching (hold)

    'touchend' 
        stops touching the screen

    touches Property    
        array-like object of points since event objects doesnt have a single set of coordinates with them (multiple fingers touching whereas there is only one mouse pointer)

        each array-like object has clientX, clientY, pageX, and pageY properties

        we can loop through each event.touches so we can simulate every touching finger

        note: preventDefault override the browser's default behavior like:
            scrolling the page on swiping
            prevent mouse events from bei
            
SCROLL EVENTS 
    'scroll' event
        uses:
            where the user is currently looking at

            showing indications of progress

    event handler is only called after the scrolling takes place that's why preventDefault does not prevent the scrolling from happening

FOCUS EVENTS 
    'focus' event  
        gains focus 

    'blur'
        loose focus

    these two events do not propagate! 

LOAD EVENT 
    'load' event
        when a page finishes from loading
        actions that require the whole document to be built 
        when the references/external files were loaded 

    loading events do not propagate! 

    'beforeunload' event 
        page is closed or navigated away from 
        main use is to prevent the user from accidentally losing work by closing a document 

        preventDefault and returnValue set to string
            this will show a user dialog like this: 

            eg. "are you sure you want to follow this link?" 

EVENTS AND THE EVENT LOOP 
    web workers 
        JS process that runs alongside the main script on its own timeline 
        does not hinder the page loading process 

        do not share their global scope with the main script

        eg 
            let squareWorker = new Worker("code/squareworker.js");
            squareWorker.addEventListener("message", event => {
            console.log("The worker responded:", event.data);
            });
            squareWorker.postMessage(10);
            squareWorker.postMessage(24);

        only values that can be represented as JSON can be sent as message (so parang strings)
        
        copy lang marereceive nung other side, not the real value

TIMERS 
    'setTimeout' function
        schedules another function to be called later after given a number of milliseconds 

    canceling a function you have scheduled:

        storing the value returned by setTimeout
        calling clearTimeout on it 

        eg. 
            let bombTimer = setTimeout(() => {
            console.log("BOOM!");
            }, 500);

            if (Math.random() < 0.5) { // 50% chance
            console.log("Defused.");
            clearTimeout(bombTimer);
            }


    'cancelAnimationFrame' works the same as clearTimeout 
        you need to store first the value returned by requestAnimationFrame, then call cancelAnimationFrame

    'setInterval' and 'clearInterval' 
        works the same too 

DEBOUNCING
    this is like setting a timeout for the firing the event 

    eg. someone is typing too fast, you do not want to record every keypress of it, because it will fire too many events. instead, you fire a keypress event after sometime the user has paused typing 

    eg. 

        <textarea>Type something here...</textarea>
        <script>
        let textarea = document.querySelector("textarea");
        let timeout;
        textarea.addEventListener("input", () => {
            clearTimeout(timeout);
            timeout = setTimeout(() => console.log("Typed!"), 500);
        });
        </script>

    
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pseudoclasses</title>
    <link rel="stylesheet" href="./style.css" type="text/CSS">
</head>
<body>
    <!--  
        original pseudoclasses (CSS 2.1) 

        :hover 
            selects an element only when it is being hovered by a mouse pointer

        :focus
            selects an element only when it is focused 

        :active
            selects an element only when it is being activated (clicked on, or then the Return/Enter key is being pressed down)
        

        CSS Basic UI Level 3 pseudoclasses
            most of these are based on their validation state

        :required and :optional
            targets required or optional form controls 
        
        :valid and :invalid, and :in-range and :out-of-range
            target form controls that are valid/invalid according to form validation constraints set on them, or in-range/out-of-range.

        :enabled and :disabled, and :read-only and :read-write
            target enabled or disabled form controls (e.g. with the disabled HTML attribute set), and read-write or read-only form controls (e.g. with the readonly HTML attribute set).

        :checked, :indeterminate, and :default
            target checkboxes and radio buttons that are checked, in an indeterminate state (neither checked or not checked), and the default selected option when the page loads
    -->

    <!-- :required and :optional -->
    <p>Required fields are labelled with "required".</p>

    <form>
        <fieldset>
          <legend>Feedback form</legend>
          <div>
            <label for="fname">First name: </label>
            <input id="fname" name="fname" type="text" required>
            <span></span>
          </div>
          <div>
            <label for="lname">Last name: </label>
            <input id="lname" name="lname" type="text" required>
            <span></span>
          </div>
          <div>
            <label for="email">Email address (include if you want a response): </label>
            <input id="email" name="email" type="email">
          </div>
          <div><button>Submit</button></div>
        </fieldset>
    </form>

    <!--  
        :valid and :invalid 
            Controls with no constraint validation will always be valid, and therefore matched with :valid.

            Controls with required set on them that have no value are counted as invalid — they will be matched with :invalid and :required.

            Controls with built-in validation, such as <input type="email"> or <input type="url"> are (matched with) :invalid when the data entered into them does not match the pattern they are looking for (but they are valid when empty).

            Controls whose current value is outside the range limits specified by the min and max attributes are (matched with) :invalid, but also matched by :out-of-range, as you'll see later on.
    -->
    <h1>valid and invalid example</h1>
    <a href="./valid-invalid.html">see example here</a>

    <!--  
        :in-range and :out-of-range
    -->
    <h1>out of range example</h1>
    <a href="./out-of-range.html">see example here</a>
    
    <!--  
        :enabled, :disabled, :read-only, and :read-write
    -->
    <h1>enabled, disabled example</h1>
    <a href="./enabled.html">see example here</a>

    <h1>readonly and readwrite example</h1>
    <a href="./readonly-confirmation.html">see example</a>
    <!--  
        Note: 
            :enabled and :read-write are two more pseudo-classes that you'll probably rarely use, given that they describe the default states of input elements.
    -->

    <!--  
        Radio and checkbox states — checked, default, indeterminate
            other states: 
                :default
                    checked by default

                :indeterminate
                    neither checked nor unchecked

                    includes: 
                        <input/radio> inputs, when all radio buttons in a same-named group are unchecked

                        <input/checkbox> inputs whose indeterminate property is set to true via JavaScript

                        <progress> elements that have no value.
    -->
    <h1>radio checked and default example</h1>
    <a href="./radios-checked-default.html">see example</a>
    
    <!-- useful for requiring in selecting at least one option -->
    <h1>radio indeterminate example</h1>
    <a href="./radios-checked-indeterminate.html"></a>

    <!-- 
        More pseudoclasses 
            The following are fairly well-supported in modern browsers:

                The :focus-within pseudo-class matches an element that has received focus or contains an element that has received focus. This is useful if you want a whole form to highlight in some way when an input inside it is focused.

                The :focus-visible pseudo-class matches focused elements that received focus via keyboard interaction (rather than touch or mouse) — useful if you want to show a different style for keyboard focus compared to mouse (or other) focus.

                The :placeholder-shown pseudo-class matches <input> and <textarea> elements that have their placeholder showing (i.e. the contents of the placeholder attribute) because the value of the element is empty.
            
            The following are also interesting, but as yet not well-supported in browsers:

                The :blank pseudo-class selects empty form controls. :empty also matches elements that have no children, like <input>, but it is more general — it also matches other empty elements like <br> and <hr>. :empty has reasonable browser support; the :blank pseudo-class's specification is not yet finished, so it not yet supported in any browser.
                
                The :user-invalid pseudo-class, when supported, will be similar to :invalid, but with better user experience. If the value is valid when the input receives focus, the element may match :invalid as the user enters data if the value is temporarily invalid, but will only match :user-invalid when the element loses focus. If the value was originally invalid, it will match both :invalid and :user-invalid for the whole duration of the focus. In a similar manner to :invalid, it will stop matching :user-invalid if the value does become valid.

    
    -->
</body>
</html>